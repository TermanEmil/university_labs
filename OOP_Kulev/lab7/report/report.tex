\documentclass{article}

\usepackage{caption}
\usepackage{booktabs}
\usepackage{indentfirst}

\usepackage{silence}
\WarningFilter{latex}{You have requested package}

\usepackage{lib/myIncludeImg}
\usepackage{lib/defaultReportSettings}
\usepackage{lib/myTitlePage}
\usepackage{lib/myFigure}
\usepackage{lib/customCppLstling}
\usepackage{lib/customHyperRef}

\begin{document}
	\def \reportSubj{Polymorfism and virtual functions}
	\myTitlePage{OOP}{Terman Emil FAF161}[M. Kulev][\reportSubj][7]

	\section{Objectives}
		\begin{itemize}
			\item studierea necesităţii şabloanelor;
			\item studierea regulilor de definire şi utilizare a şabloanelor;
			\item studierea specializării şabloanelor;
			\item studierea potenţialelor probleme rezolvate cu ajutorul şabloanelor;
		\end{itemize}

	\section{Main notions of theory and used methods}
		\par Templates are parametrized by one or more template parameters, of three kinds: type template parameters, non-type template parameters, and template template parameters.

		\par When template arguments are provided, or, for function and class (since C++17) templates only, deduced, they are substituted for the template parameters to obtain a specialization of the template, that is, a specific type or a specific function lvalue. Specializations may also be provided explicitly: full specializations are allowed for both class and function templates, partial specializations are only allowed for class templates.

		\par When a class template specialization is referenced in context that requires a complete object type, or when a function template specialization is referenced in context that requires a function definition to exist, the template is instantiated (the code for it is actually compiled), unless the template was already explicitly specialized or explicitly instantiated. Instantiation of a class template doesn't instantiate any of its member functions unless they are also used. At link time, identical instantiations generated by different translation units are merged.

		\par The definition of a template must be visible at the point of implicit instantiation, which is why template libraries typically provide all template definitions in the headers (e.g. most boost libraries are header-only)

	\section{Task}
		\begin{enumerate}
			\item Creaţi o funcţie şablon, care schimbă ordinea elementelor în felul următor: prima parte a listei se amestecă la urmă, dar a doua la început.  De exemplu:  1 2 3 4 5 6  -  4 5 6 1 2 3. Funcţia trebuie să lucreze cu masive de lungimi diferite. Dacă numărul de elemente este impar, atunci elementul mijlociu nu trebuie de prelucrat.

			\item Creaţi clasa parametrizată Stack. Clasa trebuie să conţină constructorii, destructorii, şi deasemenea funcţiile push, pop, empty, full şi operatorii de intrare/ieşire. Pentru alocarea memoriei să se utilizeze operatorul new.
		\end{enumerate}

	\section{Data analysis}
		\subsection{Ex00}

		\begin{center}
			\labelRef{ex00_main}[The code]
		\end{center}

		\begin{minipage}{\textwidth}
			\par \cppInLine{template <typename T>}
			\par \cppInLine{std::vector<T> myShuffle(std::vector<T> tab);}
		\end{minipage}

		\begin{itemize}
			\item \cppInLine{tab} is the target vector from which to make the shuffle;
			\item the function returns a new vector with the first half at the end;
		\end{itemize}

		\subsection{Ex01}

		\begin{center}
			\labelRef{ex01_stack}[The code]
		\end{center}

		\par The \textit{Stack} class contains a `stack' of \textit{GenericNode}s remembered in the \textit{last\_} private field.

		\begin{itemize}
			\item
				\par \cppInLine{void Push(T newData);}
				\par Add a new element in the stack, increasing the \textit{size\_} value.

			\item
				\par \cppInLine{T Pop();}
				\par Remove the first element from the stack and return it.
		\end{itemize}


	\section{Analysis of the results and conclusions}
		\par In this laboratory work, we studied Generic functions and classes. It's another, very critical feature of C++ that puts a big distance between C and C++, making easier to code.
		\begin{itemize}
			\item in comparison with C, the Generics feature introduced in C++ is very useful, because it would be necessary to use many \textit{cast}s or \textit{define}s to acomplish the same results in C (if possible);

			\item templates have a big drawback, it's possible to find the errors only at runtime. But it's natural, because the compiler has no way to know how much memory the \textit{typename} needs;

			\item basically, templates are compiler friendly \textit{define}s;
		\end{itemize}

	\section{Anexes}
		\begin{center}

		\begin{minipage}{\textwidth}
			\includeCPPFile{../code/ex00/src/main.cpp}[main.cpp][ex00_main]
		\end{minipage}

		\begin{minipage}{\textwidth}
			\includeCPPFile{../code/ex01/includes/stack.h}[stack.h][ex01_stack]
		\end{minipage}

		\begin{minipage}{\textwidth}
			\def \genericNodeCodePath {../code/ex01/includes/generic_node.h}
			\includeCPPFile{\genericNodeCodePath}[`generic\string_node.h']
		\end{minipage}

		\begin{minipage}{\textwidth}
			\includeCPPFile{../code/ex01/src/main.cpp}[main.cpp][ex01_main]
		\end{minipage}

		\end{center}
\end{document}